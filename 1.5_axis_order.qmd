---
title: 三维轴序约定
format:
  html:
    code-fold: false
    toc: true
sidebar: zh
---


## 1. 问题描述：SimpleITK 的轴序不一致

在使用SimpleITK处理医学影像时，一个常见的问题是`SimpleITK.Image`对象和它转换成的NumPy数组在轴的顺序上不一致。具体来说，`image.GetSize()`返回的维度顺序是 `(X, Y, Z)`，而`sitk.GetArrayFromImage(image)`返回的NumPy数组的 `shape` 属性却是 `(Z, Y, X)`。

下面的代码演示了这个问题：

```{python}
import SimpleITK as sitk
dirname = "dicube-testdata/dicom/sample_200"

reader = sitk.ImageSeriesReader()
dicom_names = reader.GetGDCMSeriesFileNames(dirname)
reader.SetFileNames(dicom_names)
sitk_image = reader.Execute()

# SimpleITK Image对象的尺寸，顺序为 (X, Y, Z)
print("image.GetSize() ->", sitk_image.GetSize(), "(X, Y, Z)")

# 转换成NumPy数组后，shape的顺序为 (Z, Y, X)
array = sitk.GetArrayFromImage(sitk_image)
print("array.shape ->", array.shape, "(Z, Y, X)")
```

这种不一致并非程序错误，而是一个为了性能而做的设计选择。它源于不同编程生态系统对多维数组存储方式的历史差异。

## 2. 历史背景：行优先 (C-Order) 与列优先 (F-Order)

计算机内存本质上是一维线性的。多维数组在内存中的存储方式主要有两种标准：

1.  **行优先 (Row-Major Order / C-Order)**：这是C/C++、Python (NumPy) 等语言的默认方式。数据按行连续存储。对于一个三维图像，其访问顺序通常被理解为 `(深度, 高度, 宽度)`，即 `(Z, Y, X)`。

2.  **列优先 (Column-Major Order / F-Order)**：这是Fortran、MATLAB、R等语言的默认方式。数据按列连续存储。这种方式更贴近传统的笛卡尔坐标系，访问顺序通常被理解为 `(X, Y, Z)`。

医学影像领域的许多基础库，如ITK、VTK，以及DICOM标准的设计，都深受Fortran科学计算传统的影响，因此其内部数据表示和元数据都遵循 `(X, Y, Z)` 的列优先约定。SimpleITK作为ITK的接口，自然也继承了这一约定。

## 3. 技术原理：零拷贝转换及其后果

当调用 `sitk.GetArrayFromImage()` 时，SimpleITK 为了最大化效率，采用了零拷贝（Zero-Copy）机制。它不会在内存中重新排列数据来适应 NumPy 的行优先标准，而是直接将 ITK 管理的内存块暴露给 NumPy，同时提供一套新的“解读规则”（即 `shape` 和 `strides` 元数据），让 NumPy 能以行优先的方式去理解这段原本按列优先存储的数据。

我们可以用NumPy模拟这个过程。对于同一段线性数据，可以通过不同的`strides`（步长）信息，将其解释为不同的多维结构。

```{python}
import numpy as np
import time

# 假设一段线性内存数据
original_data = np.arange(10)
print(f"原始线性数据: {original_data}")

# 按C-order (行优先) 解释
c_order_array = np.reshape(original_data, (2, 5), order='C')
print(f"\nC-order 数组:\n{c_order_array}")
# 要移动到下一行(从0到5)，内存指针需要跳过5个元素
print(f"C-order Strides: {c_order_array.strides}") 

# 按F-order (列优先) 解释
f_order_array = np.reshape(original_data, (5, 2), order='F')
print(f"\nF-order 数组:\n{f_order_array}")
# 要移动到下一行(从0到1)，内存指针只需要跳过1个元素
print(f"F-order Strides: {f_order_array.strides}")
```

SimpleITK的零拷贝操作虽然速度极快，但其直接后果就是轴序的翻转 `(X, Y, Z) -> (Z, Y, X)`。这个结果给开发者带来了实际的编程负担和潜在风险。

## 4. 给开发者带来的实际问题

轴序不一致会引发两类主要问题：认知负担和性能开销。

### 4.1. 认知负担与常见错误

开发者必须在编码时持续关注轴序的转换，这很容易导致错误：

  - **元数据不匹配**：`image.GetSpacing()`返回的体素间距是 `(X, Y, Z)` 顺序，必须手动将其与 `(Z, Y, X)` 顺序的数组对应起来，例如 `spacing_z = spacing_xyz[2]`。
  - **索引错误**：对数组进行切片或索引时，很容易下意识地使用 `(x, y, z)` 顺序，而正确的应该是 `array[z, y, x]`。
  - **函数参数错误**：在使用如`scipy.ndimage.zoom`等需要数组和参数轴序对应的函数时，极易传错参数顺序，导致非预期的空间变换结果。

### 4.2. 手动修正的性能代价

一个直接的想法是获取数组后立即使用 `.transpose(2, 1, 0)` 将其手动转换为 `(X, Y, Z)` 顺序，然后所有的 python 代码也在  `(X, Y, Z)` 上进行，这样全部与simpleitk 的生态保持一致。然而，这个操作并非没有代价。

**1. 创建非连续数组**
首先，我们创建一个模拟真实图像的连续数组。

```{python}
# 创建一个200x300x400的连续数组 (ZYX)
large_array_zyx = np.random.rand(399, 400, 401).astype(np.float32)
print(f"原始数组 C-contiguous: {large_array_zyx.flags['C_CONTIGUOUS']}")
```

`.transpose()` 操作本身很快，因为它不移动数据，只改变`strides`信息。但它会产生一个\*\*非连续（Non-Contiguous）\*\*的数组视图。

```{python}
# 转置操作 (ZYX -> XYZ)
transposed_view_xyz = large_array_zyx.transpose(2, 1, 0)
print(f"转置后视图 C-contiguous: {transposed_view_xyz.flags['C_CONTIGUOUS']}")
```

**2. 非连续数组的计算性能**
在非连续数组上进行运算时，由于数据在内存中是跳跃访问的，会降低CPU缓存命中率，导致计算性能下降。
```{python}
def benchmark_operation(arr, name):
    start = time.time()
    _ = np.sum(arr[60:100] * 2.0 + 1.0)
    end = time.time()
    exec_time = (end - start) * 1000
    print(f"  {name}: {exec_time:.2f} ms")
    return exec_time

original_time = benchmark_operation(large_array_zyx, "在原始连续数组上计算")
view_time = benchmark_operation(transposed_view_xyz, "在转置视图(非连续)上计算")
print(f"  性能差异: 转置视图计算慢约 {(view_time/original_time-1)*100:.1f}%")
```

**3. 外部库的连续性要求**
问题进一步复杂化的是，许多外部库和工具明确要求输入数组必须是C连续的（C-contiguous）：

- **深度学习框架**：PyTorch的 `torch.from_numpy()` 和TensorFlow的张量转换都要求输入数组是C-contiguous的
- **GPU计算**：CUDA kernels和OpenCL通常需要连续的内存布局来实现高效的GPU内存传输
- **ONNX推理**：多数ONNX Runtime后端要求模型输入为连续数组
- **图像处理库**：OpenCV的某些函数和skimage的部分算法对内存布局有严格要求

这意味着在将转置后的非连续数组传递给这些库之前，必须先进行连续化处理。

**4. 恢复连续性的开销**
要解决性能问题和兼容性问题，需要调用`np.ascontiguousarray()`，但这会触发一次完整的内存拷贝，消耗额外的时间和一倍的内存。

```{python}
start_time = time.time()
contiguous_copy_xyz = np.ascontiguousarray(transposed_view_xyz)
contiguous_time = (time.time() - start_time) * 1000

print(f"强制连续化(内存拷贝)耗时: {contiguous_time:.1f} ms")
print(f"新数组 C-contiguous: {contiguous_copy_xyz.flags['C_CONTIGUOUS']}")
print(f"额外内存占用: {contiguous_copy_xyz.nbytes / 1024 / 1024:.1f} MB")
```

结论是，手动修正轴序问题，要么牺牲计算性能和访问效率，要么付出高昂的时间和内存成本。这个代价在深度学习和GPU计算场景中尤其显著，因为每次模型推理都需要进行连续化处理。

## 5. DiCube的解决方案：设计上的一致性

DiCube的设计哲学是将复杂性封装在库内部，为用户提供一个简单、一致的编程接口。它选择在数据加载阶段一次性解决轴序问题。

当使用`dicube.load_from_dicom_folder()`时，DiCube执行了以下操作：

1.  读取原始数据和元数据。
2.  使用`(Z, Y, X)` + C-continuous的方式重新解释内存布局，无需内存重排。
3.  同时，将空间元数据的xyz轴进行翻转，使spacing等元数据也符合 `(Z, Y, X)` 顺序。

这样，用户从DiCube获取的数据和元数据在轴序上是完全统一的，可以直接用于Python生态中的其他库。

下面的代码对比了DiCube和SimpleITK的输出：

```{python}
import dicube
# 使用DiCube加载同一份数据
dcb_image = dicube.load_from_dicom_folder(dirname, sort_method=dicube.SortMethod.POSITION_RIGHT_HAND)

print("--- DiCube: 轴序一致 ---")
# 数组shape是 (Z, Y, X)
print('dicube array.shape ->', dcb_image.get_fdata().shape, '(Z, Y, X)')
# space.spacing也是 (Z, Y, X)
print('dicube space.spacing ->', dcb_image.space.spacing, '(Z, Y, X)')
# 索引直接对应
print(f"  数组轴0(Z)的spacing为: {dcb_image.space.spacing[0]}")

print("\n--- SimpleITK: 轴序不一致 ---")
# 数组shape是 (Z, Y, X)
print("simpleitk array.shape ->", array.shape, "(Z, Y, X)")
# GetSpacing()是 (X, Y, Z)
print("simpleitk image.GetSpacing() ->", sitk_image.GetSpacing(), "(X, Y, Z)")
# 索引需要转换
print(f"  数组轴0(Z)的spacing为: {sitk_image.GetSpacing()[2]}")
```

由于DiCube只是重新解释内存布局和翻转space轴序，没有实际的内存重排开销。它通过提供一个统一且符合Python开发者直觉的接口，从根本上消除了后续处理流程中所有因轴序不一致而引发的认知负担和潜在错误。
